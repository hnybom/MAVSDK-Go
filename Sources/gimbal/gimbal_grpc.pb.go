// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.9
// source: gimbal.proto

package gimbal

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// GimbalServiceClient is the client API for GimbalService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GimbalServiceClient interface {
	// Set gimbal pitch and yaw angles.
	//
	// This sets the desired pitch and yaw angles of a gimbal.
	// Will return when the command is accepted, however, it might
	// take the gimbal longer to actually be set to the new angles.
	SetPitchAndYaw(ctx context.Context, in *SetPitchAndYawRequest, opts ...grpc.CallOption) (*SetPitchAndYawResponse, error)
	// Set gimbal angular rates around pitch and yaw axes.
	//
	// This sets the desired angular rates around pitch and yaw axes of a gimbal.
	// Will return when the command is accepted, however, it might
	// take the gimbal longer to actually reach the angular rate.
	SetPitchRateAndYawRate(ctx context.Context, in *SetPitchRateAndYawRateRequest, opts ...grpc.CallOption) (*SetPitchRateAndYawRateResponse, error)
	// Set gimbal mode.
	//
	// This sets the desired yaw mode of a gimbal.
	// Will return when the command is accepted. However, it might
	// take the gimbal longer to actually be set to the new angles.
	SetMode(ctx context.Context, in *SetModeRequest, opts ...grpc.CallOption) (*SetModeResponse, error)
	// Set gimbal region of interest (ROI).
	//
	// This sets a region of interest that the gimbal will point to.
	// The gimbal will continue to point to the specified region until it
	// receives a new command.
	// The function will return when the command is accepted, however, it might
	// take the gimbal longer to actually rotate to the ROI.
	SetRoiLocation(ctx context.Context, in *SetRoiLocationRequest, opts ...grpc.CallOption) (*SetRoiLocationResponse, error)
	// Take control.
	//
	// There can be only two components in control of a gimbal at any given time.
	// One with "primary" control, and one with "secondary" control. The way the
	// secondary control is implemented is not specified and hence depends on the
	// vehicle.
	//
	// Components are expected to be cooperative, which means that they can
	// override each other and should therefore do it carefully.
	TakeControl(ctx context.Context, in *TakeControlRequest, opts ...grpc.CallOption) (*TakeControlResponse, error)
	// Release control.
	//
	// Release control, such that other components can control the gimbal.
	ReleaseControl(ctx context.Context, in *ReleaseControlRequest, opts ...grpc.CallOption) (*ReleaseControlResponse, error)
	// Subscribe to control status updates.
	//
	// This allows a component to know if it has primary, secondary or
	// no control over the gimbal. Also, it gives the system and component ids
	// of the other components in control (if any).
	SubscribeControl(ctx context.Context, in *SubscribeControlRequest, opts ...grpc.CallOption) (GimbalService_SubscribeControlClient, error)
}

type gimbalServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGimbalServiceClient(cc grpc.ClientConnInterface) GimbalServiceClient {
	return &gimbalServiceClient{cc}
}

func (c *gimbalServiceClient) SetPitchAndYaw(ctx context.Context, in *SetPitchAndYawRequest, opts ...grpc.CallOption) (*SetPitchAndYawResponse, error) {
	out := new(SetPitchAndYawResponse)
	err := c.cc.Invoke(ctx, "/mavsdk.rpc.gimbal.GimbalService/SetPitchAndYaw", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gimbalServiceClient) SetPitchRateAndYawRate(ctx context.Context, in *SetPitchRateAndYawRateRequest, opts ...grpc.CallOption) (*SetPitchRateAndYawRateResponse, error) {
	out := new(SetPitchRateAndYawRateResponse)
	err := c.cc.Invoke(ctx, "/mavsdk.rpc.gimbal.GimbalService/SetPitchRateAndYawRate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gimbalServiceClient) SetMode(ctx context.Context, in *SetModeRequest, opts ...grpc.CallOption) (*SetModeResponse, error) {
	out := new(SetModeResponse)
	err := c.cc.Invoke(ctx, "/mavsdk.rpc.gimbal.GimbalService/SetMode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gimbalServiceClient) SetRoiLocation(ctx context.Context, in *SetRoiLocationRequest, opts ...grpc.CallOption) (*SetRoiLocationResponse, error) {
	out := new(SetRoiLocationResponse)
	err := c.cc.Invoke(ctx, "/mavsdk.rpc.gimbal.GimbalService/SetRoiLocation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gimbalServiceClient) TakeControl(ctx context.Context, in *TakeControlRequest, opts ...grpc.CallOption) (*TakeControlResponse, error) {
	out := new(TakeControlResponse)
	err := c.cc.Invoke(ctx, "/mavsdk.rpc.gimbal.GimbalService/TakeControl", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gimbalServiceClient) ReleaseControl(ctx context.Context, in *ReleaseControlRequest, opts ...grpc.CallOption) (*ReleaseControlResponse, error) {
	out := new(ReleaseControlResponse)
	err := c.cc.Invoke(ctx, "/mavsdk.rpc.gimbal.GimbalService/ReleaseControl", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gimbalServiceClient) SubscribeControl(ctx context.Context, in *SubscribeControlRequest, opts ...grpc.CallOption) (GimbalService_SubscribeControlClient, error) {
	stream, err := c.cc.NewStream(ctx, &GimbalService_ServiceDesc.Streams[0], "/mavsdk.rpc.gimbal.GimbalService/SubscribeControl", opts...)
	if err != nil {
		return nil, err
	}
	x := &gimbalServiceSubscribeControlClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GimbalService_SubscribeControlClient interface {
	Recv() (*ControlResponse, error)
	grpc.ClientStream
}

type gimbalServiceSubscribeControlClient struct {
	grpc.ClientStream
}

func (x *gimbalServiceSubscribeControlClient) Recv() (*ControlResponse, error) {
	m := new(ControlResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// GimbalServiceServer is the server API for GimbalService service.
// All implementations must embed UnimplementedGimbalServiceServer
// for forward compatibility
type GimbalServiceServer interface {
	// Set gimbal pitch and yaw angles.
	//
	// This sets the desired pitch and yaw angles of a gimbal.
	// Will return when the command is accepted, however, it might
	// take the gimbal longer to actually be set to the new angles.
	SetPitchAndYaw(context.Context, *SetPitchAndYawRequest) (*SetPitchAndYawResponse, error)
	// Set gimbal angular rates around pitch and yaw axes.
	//
	// This sets the desired angular rates around pitch and yaw axes of a gimbal.
	// Will return when the command is accepted, however, it might
	// take the gimbal longer to actually reach the angular rate.
	SetPitchRateAndYawRate(context.Context, *SetPitchRateAndYawRateRequest) (*SetPitchRateAndYawRateResponse, error)
	// Set gimbal mode.
	//
	// This sets the desired yaw mode of a gimbal.
	// Will return when the command is accepted. However, it might
	// take the gimbal longer to actually be set to the new angles.
	SetMode(context.Context, *SetModeRequest) (*SetModeResponse, error)
	// Set gimbal region of interest (ROI).
	//
	// This sets a region of interest that the gimbal will point to.
	// The gimbal will continue to point to the specified region until it
	// receives a new command.
	// The function will return when the command is accepted, however, it might
	// take the gimbal longer to actually rotate to the ROI.
	SetRoiLocation(context.Context, *SetRoiLocationRequest) (*SetRoiLocationResponse, error)
	// Take control.
	//
	// There can be only two components in control of a gimbal at any given time.
	// One with "primary" control, and one with "secondary" control. The way the
	// secondary control is implemented is not specified and hence depends on the
	// vehicle.
	//
	// Components are expected to be cooperative, which means that they can
	// override each other and should therefore do it carefully.
	TakeControl(context.Context, *TakeControlRequest) (*TakeControlResponse, error)
	// Release control.
	//
	// Release control, such that other components can control the gimbal.
	ReleaseControl(context.Context, *ReleaseControlRequest) (*ReleaseControlResponse, error)
	// Subscribe to control status updates.
	//
	// This allows a component to know if it has primary, secondary or
	// no control over the gimbal. Also, it gives the system and component ids
	// of the other components in control (if any).
	SubscribeControl(*SubscribeControlRequest, GimbalService_SubscribeControlServer) error
	mustEmbedUnimplementedGimbalServiceServer()
}

// UnimplementedGimbalServiceServer must be embedded to have forward compatible implementations.
type UnimplementedGimbalServiceServer struct {
}

func (UnimplementedGimbalServiceServer) SetPitchAndYaw(context.Context, *SetPitchAndYawRequest) (*SetPitchAndYawResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPitchAndYaw not implemented")
}
func (UnimplementedGimbalServiceServer) SetPitchRateAndYawRate(context.Context, *SetPitchRateAndYawRateRequest) (*SetPitchRateAndYawRateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPitchRateAndYawRate not implemented")
}
func (UnimplementedGimbalServiceServer) SetMode(context.Context, *SetModeRequest) (*SetModeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMode not implemented")
}
func (UnimplementedGimbalServiceServer) SetRoiLocation(context.Context, *SetRoiLocationRequest) (*SetRoiLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetRoiLocation not implemented")
}
func (UnimplementedGimbalServiceServer) TakeControl(context.Context, *TakeControlRequest) (*TakeControlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TakeControl not implemented")
}
func (UnimplementedGimbalServiceServer) ReleaseControl(context.Context, *ReleaseControlRequest) (*ReleaseControlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReleaseControl not implemented")
}
func (UnimplementedGimbalServiceServer) SubscribeControl(*SubscribeControlRequest, GimbalService_SubscribeControlServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeControl not implemented")
}
func (UnimplementedGimbalServiceServer) mustEmbedUnimplementedGimbalServiceServer() {}

// UnsafeGimbalServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GimbalServiceServer will
// result in compilation errors.
type UnsafeGimbalServiceServer interface {
	mustEmbedUnimplementedGimbalServiceServer()
}

func RegisterGimbalServiceServer(s grpc.ServiceRegistrar, srv GimbalServiceServer) {
	s.RegisterService(&GimbalService_ServiceDesc, srv)
}

func _GimbalService_SetPitchAndYaw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPitchAndYawRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GimbalServiceServer).SetPitchAndYaw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mavsdk.rpc.gimbal.GimbalService/SetPitchAndYaw",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GimbalServiceServer).SetPitchAndYaw(ctx, req.(*SetPitchAndYawRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GimbalService_SetPitchRateAndYawRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPitchRateAndYawRateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GimbalServiceServer).SetPitchRateAndYawRate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mavsdk.rpc.gimbal.GimbalService/SetPitchRateAndYawRate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GimbalServiceServer).SetPitchRateAndYawRate(ctx, req.(*SetPitchRateAndYawRateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GimbalService_SetMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetModeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GimbalServiceServer).SetMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mavsdk.rpc.gimbal.GimbalService/SetMode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GimbalServiceServer).SetMode(ctx, req.(*SetModeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GimbalService_SetRoiLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRoiLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GimbalServiceServer).SetRoiLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mavsdk.rpc.gimbal.GimbalService/SetRoiLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GimbalServiceServer).SetRoiLocation(ctx, req.(*SetRoiLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GimbalService_TakeControl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TakeControlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GimbalServiceServer).TakeControl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mavsdk.rpc.gimbal.GimbalService/TakeControl",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GimbalServiceServer).TakeControl(ctx, req.(*TakeControlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GimbalService_ReleaseControl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReleaseControlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GimbalServiceServer).ReleaseControl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mavsdk.rpc.gimbal.GimbalService/ReleaseControl",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GimbalServiceServer).ReleaseControl(ctx, req.(*ReleaseControlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GimbalService_SubscribeControl_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeControlRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GimbalServiceServer).SubscribeControl(m, &gimbalServiceSubscribeControlServer{stream})
}

type GimbalService_SubscribeControlServer interface {
	Send(*ControlResponse) error
	grpc.ServerStream
}

type gimbalServiceSubscribeControlServer struct {
	grpc.ServerStream
}

func (x *gimbalServiceSubscribeControlServer) Send(m *ControlResponse) error {
	return x.ServerStream.SendMsg(m)
}

// GimbalService_ServiceDesc is the grpc.ServiceDesc for GimbalService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GimbalService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mavsdk.rpc.gimbal.GimbalService",
	HandlerType: (*GimbalServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetPitchAndYaw",
			Handler:    _GimbalService_SetPitchAndYaw_Handler,
		},
		{
			MethodName: "SetPitchRateAndYawRate",
			Handler:    _GimbalService_SetPitchRateAndYawRate_Handler,
		},
		{
			MethodName: "SetMode",
			Handler:    _GimbalService_SetMode_Handler,
		},
		{
			MethodName: "SetRoiLocation",
			Handler:    _GimbalService_SetRoiLocation_Handler,
		},
		{
			MethodName: "TakeControl",
			Handler:    _GimbalService_TakeControl_Handler,
		},
		{
			MethodName: "ReleaseControl",
			Handler:    _GimbalService_ReleaseControl_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeControl",
			Handler:       _GimbalService_SubscribeControl_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "gimbal.proto",
}
